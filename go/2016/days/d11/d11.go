// Adventofcode 2016, d11, in go. Arguments:
// -1: use solve part 1 of the problem, default is the second one
// the input file name: default: input.txt
// TEST: -1 example 11
// TEST: -1 input 33
// #TEST: example N/A: example fails if we add the 4 new objects of part2
// TEST: input 57

// TODO: implement A* ourselves, so we can avoid re-visiting equivalent states
// (states with same metric)

package main

import (
	"flag"
	"fmt"
	"regexp"
	"sort"
	"time"
	// we could use gonum A*, but it requires creating all the states beforehand
    //   https://pkg.go.dev/gonum.org/v1/gonum/graph/path#AStar
	//   "gonum.org/v1/gonum/graph"
	//   "gonum.org/v1/gonum/graph/path"
	//   "gonum.org/v1/gonum/graph/simple"
	// So we use astar, that just asks for neighbours on demand
	"github.com/fzipp/astar"
)

var verbose bool

// a state is a series of 2-bit numbers that are the floor the object is on
// object ids are 0 for E, i*2+1, i*2+2 for metal #i G and M
// this is because there are only 4 floors and 5 metals max = 22 bits used.
// reminder conversions of N
//   decimal -> binary: strconv.FormatInt(N, 2)
//   binary -> decimal: strconv.ParseInt(N, 2, 64)

type State struct {
	id string					// an unique ID for all equivalent states
	weight int					// sum of all object heights from floor#0
	E int						// floor # of the Elevator
	G [4][]int			        // per floor list of metal IDs of generators present
	M [4][]int			        // per floor list of metal IDs of microchips present
}
type States []string				// the list of all state IDs (dynamically generated by astar)
var states map[string]State		// the cache of dynamically instancied states

var metalids map[string]int		// IDs of the G for a name
var nmetals int					// its length
var nobjs int					// number of objects (except E) : twice nmetals
var nodes int					// debug: number of nodes examined for neighbours
var goal State					// all objects on floor #3

func main() {
	partOne := flag.Bool("1", false, "run exercise part1, (default: part2)")
	partThree := flag.Bool("3", false, "run exercise part2, with the A* implementation of the gonum/path package instead of the fzipp/astar of part2 (default)")
	verboseFlag := flag.Bool("v", false, "verbose: print extra info")
	flag.Parse()
	verbose = *verboseFlag
	infile := "input.txt"
	if flag.NArg() > 0 {
		infile = flag.Arg(0)
	}
	lines := fileToLines(infile)

	var result int
	if *partOne {
		VP("Running Part1")
		result = part1(lines)
	} else if *partThree {
		VP("Running Part3 = Part2 with gonum/path implementation")
		result = part3(lines)
	} else {
		VP("Running Part2, fzipp/astar implementation")
		result = part2(lines)
	}
	fmt.Println(result)
}

//////////// Part 1

func part1(lines []string) int {
	start := parse(lines)
	VPf("Looking for path to %v\n", goal)
	states := States{}
	startTime := time.Now().UnixMilli()
	path := astar.FindPath[string](states, start, goal.id, stateDist, stateDist)
	endTime := time.Now().UnixMilli()
	fmt.Printf("Number of explored nodes: %d, in %.0fms\n", nodes, float64(endTime - startTime))
	return len(path) - 1		// path includes both ends
}

//////////// Part 2
func part2(lines []string) int {
	// we just insert the elerium and dilithium Gs & Ms in floor 0
	lines[0] = lines[0] + " And also a elerium generator, a elerium-compatible microchip, a dilithium generator, a dilithium-compatible microchip."
	return part1(lines)
}

//////////// Common Parts code

func parse(lines []string) string {
	var state State
	metalids = make(map[string]int, 0)
	metalidslist := []int{}			// list  of all metalids
	re := regexp.MustCompile(" [Aa]n? (([[:alpha:]]+) generator|([[:alpha:]]+)-compatible microchip)")
	// Elevator starts on the first floor (#0): state.E = 0
	for floor := 0; floor < 4; floor++ { // inputs describe a floor per line
		for _, m := range re.FindAllStringSubmatch(lines[floor], -1) { // examine all mentions of objects
			VPf("On floor #%d, parsing G = \"%s\", M = \"%s\"\n", floor, m[2], m[3])
			var id int
			var isMC, ok bool
			metal := m[2]
			if metal == "" {
				isMC = true
				metal = m[3]
			}
			if id, ok = metalids[metal]; !ok { // metal not yet seen, allocate room for it
				id = len(metalids)
				metalids[metal] = id
				metalidslist = append(metalidslist, id)
			}
			if isMC {
				state.M[floor] = append(state.M[floor], id)
			} else {
				state.G[floor] = append(state.G[floor], id)
			}
		}
	}
	nmetals = len(metalids)
	nobjs = nmetals * 2
	states = make(map[string]State, 0)
	state.id = stateId(state)
	state.weight = stateWeight(state)
	states[state.id] = state
	// compute goal state
	goal = State{E:3, G:[4][]int{nil, nil, nil, metalidslist}, M:[4][]int{nil, nil, nil, metalidslist}}
	goal.id = stateId(goal)
	goal.weight = stateWeight(goal)
	states[goal.id] = goal
	VPf("%d metals, Initial state: %v\nGoal: %v\n", nmetals, state, goal)
	return state.id
}

// we use an ID covering all equivalent states
// As all pairs G,M are interchangeable for each metal, the following two states are
// EQUIVALENT: AG@0 AM@1 BG@3 BM@2 and AG@3 AM@2 BG@0 BM@1
// so for each [G,M] config possible (4X4 = 16 possibilities), we count the number of metals
// in these configs, and encode them in a string of 17 letters: 1 for E, 16 for metals
func stateId(s State) string {
	id := string('0' + s.E)
	metalpairs := make([]int, nmetals, nmetals)
	for f := 0; f < 4; f++ {
		for _, g := range s.G[f] {
			metalpairs[g] += f
		}
		for _, m := range s.M[f] {
			metalpairs[m] += f * 4
		}
	}
	sort.Slice(metalpairs, func(i, j int) bool {
		return metalpairs[i] > metalpairs[j]
	})
	for _, n := range metalpairs {
		id += string('0' + n)
	}
	return id
}

func stateWeight(s State) int {
	w := s.E
	for floor := 0; floor < 4; floor++ {
		w += floor * (len(s.G[floor]) + len(s.M[floor]))
	}
	return w
}

// clone a state to a different floor, moving the elevator
// weight and id not cloned: edit G and M, then re-compute them
func (s State)cloneOnFloor(floor int) (c State) {
	c.E = floor
	for f := 0; f < 4; f++ {
		if len(s.G[f]) > 0 {
			c.G[f] = make([]int, len(s.G[f]))
			copy(c.G[f], s.G[f])
		}
		if len(s.M[f]) > 0 {
			c.M[f] = make([]int, len(s.M[f]))
			copy(c.M[f], s.M[f])
		}
	}
	return
}

//// callbacks on States for use by astar

// we use the sum of floor distances per object = difference of weights
func stateDist(sid1, sid2 string) (float64) {
	s1 := states[sid1]
	s2 := states[sid2]
	d := s2.weight - s1.weight
	if d < 0 { d = -d;}
	return float64(d)
}

// here we implement all the constraints on object moves, to list only possible neighbour states
// - look for moves to next or previous floor of E only
// - E goes to tofloor
// - of 1 or 2 objects (not counting E)
// - on fromfloor and tofloor, there must be no G or all M are connected to their G

func (g States) Neighbours(sid string) (nexts []string) {
	nodes++
	f := states[sid].E
	if f > 0 {
		nexts = append(nexts, floorNeighbours(sid, f, f-1)...)
	}
	if f < 3 {
		nexts = append(nexts, floorNeighbours(sid, f, f+1)...)
	}
	return
}

// returns list of all neighbours on to floor (tf) of state s, from floor ff
// ignore s.E, use only ff and tf
func floorNeighbours(sid0 string, ff, tf int) (nf []string) {
	s0 := states[sid0]
	nfids := make(map[string]bool)
	for _, pair := range objPairsOnFloor(s0, ff) {
		s := s0.cloneOnFloor(tf)
		for _, o := range pair { // move the object(s) of pair from fs to tf in s
			if o >= 0 {
				s.G[ff], _ = deleteFastInt(s.G[ff], o)
				s.G[tf] = append(s.G[tf], o)
			} else {
				s.M[ff], _ = deleteFastInt(s.M[ff], -o-1)
				s.M[tf] = append(s.M[tf], -o-1)
			}
		}
		s.id = stateId(s)
		if nfids[s.id] {		// equivalent to a neighbour already in nf
			continue
		}
		if _, ok := states[s.id]; !ok {
			if isStateFloorValid(s, ff) && isStateFloorValid(s, tf) {
				s.weight = stateWeight(s) // register new valid state
				states[s.id] = s
			} else {
				continue
			}
		}
		nfids[s.id] = true
		nf = append(nf, s.id)
	}
	return
}

func isStateFloorValid(s State, floor int) bool {
	if len(s.G[floor]) == 0 {	// No Gs on floor? ==> valid
		return true
	}
	for i := 0; i < len(s.M[floor]); i ++ { // look at all Ms on floor
		if indexOfInt(s.G[floor], s.M[floor][i]) == -1 {
			return false		// a M without its G? invalid!
		}
	}
	return true
}

// return all the sets of 1 or 2 non-E objects on floor f.
// indexes are >=0 for G, <0 for M (offset by -1)
func objPairsOnFloor(s State, f int) (sets [][]int) {
	sep := len(s.G[f])
	nobjs := sep + len(s.M[f])
	for i := 0; i < nobjs ; i++ {
		var ii int
		if i < sep {
			ii = s.G[f][i]
		} else {
			ii = -s.M[f][i-sep] -1
		}
		sets = append(sets, []int{ii})
		for j := i + 1; j < nobjs; j++ {
			if j < sep {
				sets = append(sets, []int{ii, s.G[f][j]})
			} else {
				sets = append(sets, []int{ii, -s.M[f][j-sep] -1})
			}
		}
	}
	return
}

//////////// Part1 functions

//////////// Part2 functions

//////////// Debugging tools

func checkSameObjN(l1, l2 [4][]int) {
	var s1, s2 int
	for f := 0; f < 4; f++ {
		s1 += len(l1[f])
		s2 += len(l2[f])
	}
	if s1 != s2 {
		panic("Differences!")
	}

}
